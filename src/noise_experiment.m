num_frames = 256;
num_sequences = 32;
downsample = 8;

omega_stddev = 5 * pi / 180;
scale_stddev = 1; %sqrt(2);
noise_stddevs = [0, 0.01, 1, 100];

num_noises = length(noise_stddevs);

% Load some mocap sequences.
if ~exist('../data/mocap-data.mat', 'file')
  sequences = random_mocap_sequences(num_frames, num_sequences, downsample, 42);
  save('../data/mocap-data', 'sequences');
else
  data = load('../data/mocap-data');
  sequences = data.sequences;
end

% In case these parameters differed in file which we loaded.
num_frames = size(sequences, 1);
num_points = size(sequences, 2);
num_sequences = min(num_sequences, size(sequences, 4));
sequences = sequences(:, :, :, 1:num_sequences);

K = 4;

% Project on to low rank.
for i = 1:num_sequences
  S = sequences(:, :, :, i);

  % Subtract 3D centroid from each frame.
  mu = mean(S, 2);
  S = bsxfun(@minus, S, mu);

  % [F, P, 3] -> [F, 3P]
  S = reshape(S, [num_frames, 3 * num_points]);
  % Project on to set of low rank matrices.
  S = project_rank(S, K);
  % [F, 3P] -> [F, P, 3]
  S = reshape(S, [num_frames, num_points, 3]);

  % Restore centroid.
  S = bsxfun(@plus, S, mu);

  sequences(:, :, :, i) = S;
end

% Generate a camera for each sequence and project it.
scenes = generate_scene_for_each_sequence(sequences, omega_stddev, ...
    scale_stddev);

% Solvers which don't require initialization.
nrsfm_solvers = [...
  make_solver(@(projections) nrsfm_basis_constraints(projections, K), ...
    'Xiao (2004)', 'xiao-2004'), ...
];

% Methods for initializing the cameras.
camera_solvers = [...
  make_solver(@(projections) find_rotations(projections, K, 1e6), ...
    'Trace norm (regularized)', 'trace-norm-regularized'), ...
%  make_solver(@(projections) find_rotations_rigid(projections), ...
%    'Rigid', 'rigid'), ...
];

% Solvers which require initialization of cameras.
nrsfm_solvers_given_cameras = [...
  make_solver(...
    @(projections, rotations) nrsfm_constrained_nuclear_norm(projections, ...
      rotations, 1, 1, 200, 10, 10, 10), ...
    'Nuclear norm (constrained)', 'nuclear-constrained'), ...
  arrayfun(@(lambda) make_solver(...
      @(projections, rotations) nrsfm_nuclear_norm_regularizer(projections, ...
        rotations, lambda, 1, 200, 10, 10, 10), ...
      sprintf('Nuclear norm (\\lambda = %g)', lambda), ...
      sprintf('nuclear-regularized-%g', lambda)), ...
    [1e-2, 1, 1e2, 1e4]), ...
  make_solver(...
    @(projections, rotations) nrsfm_fixed_rank(projections, rotations, K, 1, ...
      1, 200, 10, 10, 10), ...
    'Fixed rank', 'fixed-rank'), ...
  make_solver(...
    @(projections, rotations) nrsfm_nullspace_alternation(projections, ...
      rotations, K, 80), ...
    'Nullspace alternation', 'nullspace-alternation'), ...
  make_solver(...
    @(projections, rotations) nrsfm_nullspace_alternation_algebraic(...
      projections, rotations, K, 80), ...
    'Nullspace alternation (algebraic)', 'nullspace-alternation-algebraic'), ...
];

%% Solvers which require initialization of cameras and coefficients.
%nrsfm_solvers_given_cameras_and_coeff = [...
%  make_solver(...
%    @(projections, rotations, coeff) nrsfm_balm_approximate(projections, ...
%      rotations, coeff), ...
%    'BALM', 'balm-approximate'), ...
%  make_solver(...
%    @(projections, rotations, coeff) nrsfm_balm_metric_projections(...
%      projections, rotations, coeff), ...
%    'BALM with metric projections', 'balm-metric'), ...
%  make_solver(...
%    @(projections, rotations, coeff) nrsfm_metric_projections(projections, ...
%      rotations, coeff), ...
%    'Alternation with metric projections', 'alternation-metric'), ...
%];

%  make_solver(...
%    @(projections, rotations) nrsfm_homogeneous_alternation(projections, ...
%      rotations), ...
%    'Homogeneous alternation', 'homogeneous-alternation'), ...

solvers = struct(...
  'nrsfm_solvers', nrsfm_solvers, ...
  'camera_solvers', camera_solvers, ...
  'nrsfm_solvers_given_cameras', nrsfm_solvers_given_cameras);

% Allocate array.
clear noisy_scenes;
noisy_scenes(num_sequences, num_noises) = struct('projections', []);

% Add noise to projections.
for i = 1:num_sequences
  projections = scenes(i).projections;
  projections = permute(projections, [3, 2, 1]);

  for j = 1:num_noises
    noise_stddev = noise_stddevs(j);

    noise = noise_stddev * randn(2, num_points, num_frames);
    noisy_scenes(i, j).projections = projections + noise;
  end
end

solutions = arrayfun(@(scene) noise_experiment_trial(solvers, scene), ...
    noisy_scenes);
