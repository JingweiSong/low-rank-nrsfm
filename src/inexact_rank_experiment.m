num_frames = 256;
num_sequences = 32;
downsample = 8;

omega_stddev = 5 * pi / 180;
scale_stddev = sqrt(2);

ranks = [2, 4, 8];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Load some mocap sequences.
if ~exist('../data/mocap-data.mat', 'file')
  sequences = random_mocap_sequences(num_frames, num_sequences, downsample, 42);
  save('../data/mocap-data', 'sequences');
else
  data = load('../data/mocap-data');
  sequences = data.sequences;
end

% In case these parameters differed in file which we loaded.
num_frames = size(sequences, 1);
num_points = size(sequences, 2);
num_sequences = min(num_sequences, size(sequences, 4));
sequences = sequences(:, :, :, 1:num_sequences);
% [F, P, 3, n] -> [3, P, F, n]
sequences = permute(sequences, [3, 2, 1, 4]);

% Generate a camera for each sequence and project it.
scenes = generate_random_scene_for_all_sequences(sequences, omega_stddev, ...
    scale_stddev);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Solvers which don't require initialization.
nrsfm_solvers = [...
  arrayfun(@(K) make_solver(...
      @(projections) nrsfm_basis_constraints(projections, K), ...
      sprintf('Xiao 2004 (K = %d)', K), sprintf('xiao-%d', K)), ...
    ranks), ...
];

% Methods for initializing the cameras.
camera_solvers = [...
  make_solver(@(projections) find_rotations_rigid(projections), ...
    'Rigid cameras', 'rigid'), ...
  arrayfun(@(K) make_solver(...
      @(projections) find_rotations_trace(projections, K, 1e6), ...
      sprintf('Trace norm cameras (K = %d)', K), sprintf('trace-%d', K)), ...
    ranks), ...
];

% Solvers which require initialization of cameras.
nrsfm_solvers_given_cameras = [...
  arrayfun(@(K) make_solver(...
      @(projections, rotations) nrsfm_nullspace_alternation(projections, ...
        rotations, K, 80), ...
      sprintf('Nullspace alternation (K = %d)', K), sprintf('null-%d', K)), ...
    ranks), ...
  arrayfun(@(K) make_solver(...
      @(projections, rotations) nrsfm_nullspace_alternation_algebraic(...
        projections, rotations, K, 80), ...
      sprintf('Algebraic nullspace alternation (K = %d)', K), ...
      sprintf('null-alg-%d', K)), ...
    ranks), ...
  make_solver(...
    @(projections, rotations) nrsfm_find_structure_adaptor(...
      @(projections, rotations) find_structure_constrained_nuclear_norm(...
        projections, rotations, [], 400, 1e-6, 1.1, 1e6), ...
      projections, rotations), ...
    'Nuclear norm (constrained)', ...
    'nuclear-equal'), ...
  arrayfun(@(K) make_solver(...
      @(projections, rotations) nrsfm_find_structure_adaptor(...
        @(projections, rotations) find_structure_nuclear_norm_sweep(...
          projections, rotations, K, [], 400, 1e-6, 1.1, 1e6), ...
        projections, rotations), ...
      sprintf('Sweep nuclear norm (K = %d)', K), ...
      sprintf('nuclear-sweep-%d', K)), ...
    ranks), ...
];

full_init_solvers = [...
  arrayfun(@(K) make_solver(...
      @(projections, rotations) nrsfm_init_find_structure_adaptor(...
        @(projections, rotations) find_structure_constrained_nuclear_norm(...
          projections, rotations, [], 400, 1e-6, 1.1, 1e6), ...
        projections, rotations, K), ...
      'Nuclear norm (constrained)', 'nuclear-equal'), ...
    ranks), ...
  arrayfun(@(K) make_solver(...
      @(projections, rotations) nrsfm_init_find_structure_adaptor(...
        @(projections, rotations) find_structure_nuclear_norm_sweep(...
          projections, rotations, K, [], 400, 1e-6, 1.1, 1e6), ...
        projections, rotations, K), ...
      sprintf('Sweep Nuclear norm (K = %d)', K), ...
      sprintf('nuclear-sweep-%d', K)), ...
    ranks), ...
];

% Solvers which require initialization of cameras and coefficients.
nrsfm_solvers_full_init = [...
  make_solver(...
    @(projections, structure, rotations, basis, coeff) ...
      nrsfm_nonlinear(projections, rotations, basis, coeff, 400, 1e-4), ...
    'Non-linear', 'nonlinear'), ...
];

solvers = struct(...
    'nrsfm_solvers', nrsfm_solvers, ...
    'camera_solvers', camera_solvers, ...
    'nrsfm_solvers_given_cameras', nrsfm_solvers_given_cameras, ...
    'full_init_solvers', full_init_solvers, ...
    'nrsfm_solvers_full_init', nrsfm_solvers_full_init);

save('inexact-experiment-setup', 'solvers', 'scenes', 'omega_stddev', 'scale_stddev');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

trial = @(scene) { experiment_trial(solvers, scene) };

if exist('pararrayfun', 'file')
  config = struct('h_cpu', '12:00:00', 'virtual_free', '1024M', ...
      'hostname', '!leffe*');
  solutions = pararrayfun(trial, scenes, numel(scenes), 'vp', config);
else
  warning('Could not find pararrayfun(), running in series.');
  solutions = arrayfun(trial, scenes(1));
end

% Repack.
num_solvers = numel(solutions{1});
solutions = reshape(cell2mat(solutions(:)), [size(solutions), num_solvers]);

save('inexact-experiment-solutions', 'solutions');
